require 'yaml'

module Stacktician
  # Use this to override existing (e.g., stackmate's) resource 
  # so that we can save the physical id to  the database
  # use include Participants
  module Participants

     # substitute for stackmate's resources with overriden classes
     # e.g, StackMate::NoOpResource gets replaced by Stacktician::NoOpResource
     def Participants.class_for(cf_resource)
       c = StackMate.class_for(cf_resource).gsub('StackMate', 'Stacktician')
     end

     #callback triggered from Ruote whenever a participant calls reply(engine)
     def on_reply(work_item)
       logger.debug "In Stacktician::on_reply #{@opts.inspect}"
       #save the physical id generated by on_workitem to the database row for the corresponding
       #stack_resource
       ActiveRecord::Base.connection_pool.with_connection do
         stack = Stack.find(@opts['stack_id'])
         resource = stack.stack_resources.find_by_logical_id(@opts['participant'])
         resource.status = 'CREATE_COMPLETE'
         #logger.info "#{work_item[@opts['participant']].inspect}"
         resource.physical_id = work_item[@opts['participant']]['physical_id']
         resource.save
       end
     end
  end

  class NoOpResource < StackMate::NoOpResource
    include Participants

    def initialize(opts)
      @opts = opts
    end

  end

  #Noop output
  class Output < Ruote::Participant

    def initialize(opts)
      @opts = opts
    end

    def logger
       ::Rails.logger
    end

    def on_workitem
      outputs = workitem.fields['Outputs']
      logger.debug "In Stacktician::Output.on_workitem #{outputs.inspect}"
      ActiveRecord::Base.connection_pool.with_connection do
        stack = Stack.find(@opts['stack_id'])
        outputs.each do |key, val|
          v = val['Value']
          logger.debug "Output: key = #{key}, value = #{v} descr = #{val['Description']}"
          stack_output = stack.stack_outputs.find_by_key(key)
          stack_output.value = v
          stack_output.save
        end
        stack.status = 'CREATE_COMPLETE'
        stack.save
      end
      reply
    end

  end

  class CloudStackInstance < StackMate::CloudStackInstance
    include Participants

    def initialize(opts)
      @opts = opts
      super(opts)
   end

   #override to read this from the environment 
   #this way if deployed in Heroku, we can use Foreman
   #to set these mappings
   def load_local_mappings()
      begin
          @localized = YAML.load(ENV['CS_LOCAL'])
      rescue
          logger.warn "Warning: Failed to load localized mappings from environment var CS_LOCAL"
      end
   end

  end

  class CloudStackSecurityGroup < StackMate::CloudStackSecurityGroup
    include Participants

    def initialize(opts)
      @opts = opts
      super(opts)
    end

  end

  # Use Ruote::StorageParticipant since it lets us 'reply_to_engine' at a
  # later time.
  class WaitCondition < Ruote::StorageParticipant

    def logger
       ::Rails.logger
    end

    def initialize(opts)
      @opts = opts
    end

    def on_workitem
      logger.debug "Entering  #{participant_name} in #{workitem.fei.wfid}"
      # WaitConditionHandle refers to its WaitHandle with a Ref:
      #"Properties" : {
      # "Handle" : {"Ref" : "WaitHandle"},
      # "Timeout" : "300"
      #
      workitem[participant_name] = {}
      props = workitem.fields['Resources'][participant_name]['Properties']
      logger.debug "#{props.inspect}"
      wait_handle_name = props['Handle']['Ref']
      workitem[participant_name][:physical_id] = workitem.fields['ResolvedNames'][wait_handle_name]
      #save the physical id as the same as the url generated by the wait handle participant
      ActiveRecord::Base.connection_pool.with_connection do
        stack = Stack.find(@opts['stack_id'])
        resource = stack.stack_resources.find_by_logical_id(@opts['participant'])
        resource.physical_id = workitem.fields['ResolvedNames'][wait_handle_name]
        resource.save
      end
      super
    end

  end

  #generates the wait condition url and stores it as 'physical_id'
  class WaitConditionHandle < Ruote::Participant
    include Participants

    def logger
       ::Rails.logger
    end

    def initialize(opts)
      @opts = opts
    end

    def on_workitem
      logger.debug "Entering #{participant_name} in #{workitem.fei.wfid}"
      workitem[participant_name] = {}
      base_url = Stacktician::CONFIG[:wait_condition_base_url]
      presigned_url = base_url + workitem.fei.wfid + '/' + participant_name 
      #TODO actually sign it
      #TODO include stack id in URL
      workitem.fields['ResolvedNames'][participant_name] = presigned_url
      workitem[participant_name][:physical_id] = presigned_url
      logger.debug "Pre-signed URL is: #{presigned_url} "
      logger.debug "Try: \ncurl -X PUT --data 'foo' #{presigned_url}"
      reply
    end

  end

  class CloudStackOutput < StackMate::CloudStackOutput

    def initialize(opts)
      @opts = opts
    end
    
    def logger
       ::Rails.logger
    end

    #mark the stack execution as complete and update the db with the outputs
    def on_reply
      outputs = workitem.fields['Outputs']
      logger.debug "In Stacktician::CloudStackOutput.on_reply #{outputs.inspect}"
      ActiveRecord::Base.connection_pool.with_connection do
        stack = Stack.find(@opts['stack_id'])
        outputs.each do |key, val|
          v = val['Value']
          logger.debug "Output: key = #{key}, value = #{v} descr = #{val['Description']}"
          stack_output = stack.stack_outputs.find_by_key(key)
          stack_output.value = v
          stack_output.save
        end
        stack.status = 'CREATE_COMPLETE'
        stack.save
      end
    end

  end
end


